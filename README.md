# Робота із шаблонами
**Мета:** Ознайомитися з принципами створення та використання шаблонів функцій і класів у мові програмування C++. Оволодіти навичками створення, використання та спеціалізації функціональних і класових шаблонів для реалізації узагальненого програмування. Написати, відлагодити та протестувати програму, у якій реалізувати основні операції із шаблонами.

## Вказівки до роботи
Відповідно до цієї інструкції вам потрібно у середовищі Visual Studio Code з використанням набору компіляторів GCC створити програму мовою C++ для роботи із шаблонами. Також реалізувати відповідні класи, конструктори, деструктори, методи. Потрібно реалізувати багатофайловий проєкт у середовищі Visual Studio Code з описом кожного класу у відповідних парах заголовного та виконуваного файлів.

## Завдання:
1. Вибрати завдання згідно свого варіанту у **ДОДАТКУ**.
2. Реалізувати клас та методи згідно заданого варіанту.
3. Продемонструйте вміння створювати повну та часткову спеціалізацію шаблону класу, щоб реалізувати специфічну поведінку для певних типів.
- часткова спеціалізація (Partial Specialization) — створіть часткову спеціалізацію шаблону.
- повна спеціалізація (Full Specialization) — створіть повну спеціалізацію шаблону.

### Короткі відомості
У мові C++ **шаблони функцій — це функції, які служать взірцем для створення інших подібних функцій**. Головна ідея — створення функцій без вказівки точного типів деяких або всіх змінних. Для цього ми визначаємо функцію, вказуючи **тип параметра шаблону**, який використовується замість будь-якого типу даних. Після того, як ми створили функцію з типом параметра шаблону, ми фактично створили «трафарет функції».

При виклику шаблону функції, компілятор використовує «трафарет» в якості зразка функції, замінюючи тип параметра шаблону на фактичний тип змінних, переданих у функцію.

Спочатку пишемо ключове слово `template`, яке повідомляє компілятору, що далі ми будемо оголошувати параметри шаблону. Параметри шаблону функції вказуються в кутових дужках (`<>`).

Для створення типів параметрів шаблону використовуються ключові слова `typename` і `class`. В базових випадках використання шаблонів функцій різниці між `typename` і `class` немає, тому ви можете вибрати будь-яке з двох. Якщо ви використовуєте ключове слово `class`, то фактичний тип параметрів не обов’язково повинен бути класом (це може бути змінна фундаментального типу даних, вказівник або щось інше). Потім даємо назву типу параметра шаблону (зазвичай `T`). Якщо потрібно кілька типів параметрів шаблону, то вони розділяються комами:
```c++
template <typename T1, typename T2>
```
Якщо параметрів кілька, то їх зазвичай називають `T1`, `T2` або іншими літерами: `T`, `S`. Оскільки тип аргументу функції, що передається в тип `T`, може бути класом, а класи, як правило, не рекомендується передавати по значенню, то краще зробити параметри і значення, що повертається, нашого шаблону функції константними посиланнями, наприклад:
```c++
template <typename T>
const T& max(const T& a, const T& b)
{
    return (a > b) ? a : b;
}
```
Мова C++ не компілює **шаблони** функцій напряму. Замість цього, коли компілятор зустрічає виклик шаблону функції, він копіює шаблон функції і замінює типи параметрів шаблону функції фактичними (переданими) типами даних. Функція з фактичними типами даних називається **екземпляром шаблону функції** (або **«об’єктом шаблону функції»**).

Шаблони класів працюють так само, як і шаблони функцій: компілятор копіює шаблон класу, замінюючи типи параметрів шаблону класу на фактичні (передані) типи даних, а потім компілює цю копію. Якщо у вас є шаблон класу, але ви його не використовуєте, то компілятор не буде його навіть компілювати.

Шаблони класів ідеально підходять для реалізації контейнерних класів, тому що дуже часто таким класам доводиться працювати з різними типами даних, а шаблони дозволяють це організувати в мінімальній кількості коду. Хоча синтаксис трохи потворний, і повідомлення про помилки іноді можуть бути «об’ємними», шаблони класів є однією з кращих і найбільш корисних конструкцій мови C++.

При створенні **екземпляра шаблону функції** для певного типу даних компілятор копіює шаблон функції і замінює параметр типу шаблону функції на фактичний (переданий) тип даних. Це означає, що всі екземпляри функції мають одну реалізацію, але різні типи даних. Хоча в більшості випадків це саме те, що потрібно, іноді може знадобитися, щоб реалізація шаблону функції для одного типу даних відрізнялася від реалізації шаблону функції для іншого типу даних.

Спеціалізація шаблонів саме для цього і призначена. Припустимо, що нам потрібно, щоб значення типу `double` (тільки типу `double`) виводилися в експоненціальному записі. Для цього ми можемо використати спеціалізацію шаблону функції (або «повну/явну спеціалізацію шаблону функції») для створення окремої версії функції `print()` для виводу значень типу `double`.

Розглянемо дуже простий шаблон класу:
```c++
template <class T>
class Repository
{
private:
    T m_value;
public:
    Repository(T value)
    {
         m_value = value;
    }
     ~Repository()
    {
    }
    void print()
    {
        std::cout << m_value << '\n';
    }
};
```
Вищенаведений код працює з багатьма типами даних:
```c++
int main()
{
    // Ініціалізуємо об'єкти класу
    Repository<int> nValue(7);
    Repository<double> dValue(8.4);
 
    // Виводимо значення об'єктів класу
    nValue.print();
    dValue.print();
}
```
Записуємо екземпляр шаблону функції (якщо функція є методом класу, то робимо це за межами класу), вказуючи потрібний нам тип даних. Наприклад, ось спеціальний шаблон функції `print()` для значень типу `double`:
```c++
template <>
void Repository<double>::print()
{
    std::cout << std::scientific << m_value << '\n';
}
```
Коли компілятору потрібно буде створити екземпляр `Repository<double>::print()`, він побачить, що ми вже явно визначили цю функцію, і тому він використовуватиме саме цей екземпляр, а не копіюватиме загальну для всіх типів даних версію шаблону функції `print().`

Частина `template <>` повідомляє компілятору, що це шаблон функції, але без параметрів (тому що в цьому випадку ми явно вказуємо потрібний нам тип даних).

Ми можемо спеціалізувати не тільки шаблони функцій, але і **шаблони класів. Спеціалізація шаблону класу** (або *«явна спеціалізація шаблону класу»*) дозволяє спеціалізувати шаблон класу для роботи з певним типом даних (або відразу з декількома типами даних, якщо є кілька параметрів шаблону).

Спеціалізація шаблону класу розглядається компілятором як повністю окремий і незалежний клас, хоч і виділяється як звичайний шаблон класу. Це означає, що ми можемо змінити в класі все що завгодно, включаючи його реалізацію/методи/специфікатори доступу тощо.

Починаємо з `template<>`. **Ключове слово** `template` повідомляє компілятору, що це шаблон, а порожні кутові дужки означають, що немає ніяких параметрів. А параметрів немає через те, що ми замінюємо єдиний параметр шаблону (`T`, який відповідає за тип даних) конкретним типом даних, наприклад `bool`. Потім ми пишемо ім’я класу і додаємо до нього `<bool>`, повідомляючи компілятору, що працюватимемо з типом `bool`.

## Оформлення звіту
У звіті студент має вказати свій варіант індивідуального завдання та представити:
1.	Блок-схему алгоритму програми.
2.	Код (лістинг) програми.
3.	Результати тестування для різних вхідних умов.
4.	Конструктивний висновок — що ви дізналися нового, чого навчилися, якими способами та інструментами досягнули мети.

## ДОДАТОК

### Варіанти завдань

|  № |              Клас             |                              Поля класу                                 |
|----|-------------------------------|-------------------------------------------------------------------------|
|  1 | Резистор                      | Номінальний опір, максимальна потужність розсіяння, клас точності       |
|  2 | Конденсатор                   | Номінальна ємність, максимальна напруга, тип матеріалу                  |
|  3 | Транзистор                    | Тип, коефіцієнт підсилення, максимальний струм                          |
|  4 | Діод                          | Пряма напруга, максимальний зворотний струм, призначення                |
|  5 | Операційний підсилювач        | Коефіцієнт підсилення, напруга живлення, кількість входів               |
|  6 | Котушка індуктивності         | Індуктивність, опір, кількість витків                                   |
|  7 | Радіопередавач                | Робоча частота, потужність, тип модуляції                               |
|  8 | Антена                        | Тип, коефіцієнт підсилення, частотний діапазон                          |
|  9 | Радіоприймач                  | Робоча частота, чутливість, тип модуляції                               |
| 10 | Осцилограф                    | Кількість каналів, смуга пропускання, тип (аналоговий/цифровий)         |
| 11 | Акумулятор                    | Ємність, напруга, тип матеріалу                                         |
| 12 | Мікросхема                    | Назва/маркування, кількість виводів, напруга живлення                   |
| 13 | Коаксіальний кабель           | Хвильовий опір, діаметр, довжина                                        |
| 14 | Датчик температури            | Тип, діапазон вимірювання, точність                                     |
| 15 | Друкована плата               | Ширина, довжина, кількість шарів                                        |
| 16 | Світлодіод                    | Колір, робочий струм, напруга                                           |
| 17 | Оптоволоконний кабель         | Кількість волокон, тип, довжина                                         |
| 18 | Аналого-цифровий перетворювач | Розрядність, частота дискретизації, кількість каналів                   |
| 19 | Мікроконтролер                | Архітектура, частота, кількість портів                                  |
| 20 | Радіореле                     | Напруга котушки, максимальний струм комутації, кількість груп контактів |
| 21 | Акустичний динамік            | Опір, потужність, діаметр                                               |
| 22 | Трансформатор                 | Коефіцієнт трансформації, первинна напруга, потужність                  |
| 23 | Генератор сигналів            | Тип сигналу, максимальна частота, наявність модуляції                   |
| 24 | Атенюатор                     | Коефіцієнт послаблення, максимальна потужність, тип                     |
| 25 | Електронний фільтр            | Тип, частота зрізу, порядок                                             |
| 26 | Телевізор                     | Діагональ екрану, роздільна здатність, наявність Smart-TV               |
| 27 | Супутник зв’язку              | Тип орбіти, кількість транспондерів, частотний діапазон                 |
| 28 | Роутер                        | Швидкість передавання даних, стандарт WiFi, кількість портів LAN        |
| 29 | Сигналізація                  | Кількість датчиків, наявність бездротових сенсорів, спосіб оповіщення   |
| 30 | Ретранслятор                  | Коефіцієнт підсилення, тип, робоча частота                              |
